
# **Инструментарий:**

Python 3.11.5

# **Использование:**

 ```python3 main.py <args>```
Аргументы:
- <формат> <округление> <число> 
- <формат> <округление> <число1> <операция> <число2>

формат – задаёт формат представления входных чисел.

Возможные варианты:

|формат| пояснение |
|-|-----------|
|A.B | числа с фиксированной точкой, где A и B – неотрицательные целые числа, обозначающие целую и дробную часть. Гарантируется, что A+B<=32 и A>=1.|
|h|числа с плавающей точкой половинной точности (half precision floating point IEEE-754), 16 бит.|
|f|формат числа с плавающей точкой одинарной точности (single precision floating point IEEE-754), 32 бита.|

Числа с фикс. точкой – числа со знаком в дополнении до 2. 

Округление – задаёт тип округления:

|тип округления|пояснение|
|--|--|
|0|к нулю (toward_zero)|
|1|к ближайшему чётному (nearest_even)|
|2|к +∞ (toward_infinity)|
|3| к -∞ (toward_neg_infinity)|

операция – символ арифметической операции: +, -, *, /. 

число – одно или два числа, записанные в 16-ричной побитовой форме с префиксом ‘0x’. Пример: 0xC4D



# **Пример работы программы:**

| arguments                   | result          |
|-----------------------------|-----------------|
| 16.12 0 0x17360             | 23.210          |
| 8.8 1 0xdc9f + 0xd736       | -76.168         |
| f 0 0xB9CD542               | 0x1.39aa84p-104 |
| f 0 0x414587dd * 0x42ebf110 | 0x1.6c1b72p+10  |
| h 0 0x4145 * 0x42eb         | 0x1.238p+3      |
| f 0 0x1 / 0x0               | inf             |

# Описание работы написанного кода:

Работа реализована в трех файлах: main.py, floating.py, fixed.py.

## main.py

Парсинг входных данных:

- перегруппировка
- некоторые проверки корректности входных (все, кроме проверки корректности входных чисел)
- обращение к необходимой функции - floating или fixed

## fixed.py

Cодержит функцию `fixed`, вызов которых реализует запрос на работу с числами с фиксированной точкой.

Эта функция содержит класс `Fixed`, экземпляр этого класса соответствует одному числу.

Так же в функции реализовано само получение результата функцией `get_res`.

Числа инициализируются своим представление в 16-ричной СС.

## Класс Fixed - реализация чисел с фиксированной точкой

### Хранение

fixed число формата A.B можно преставить как x / y, где x, y - целые, а y - степень двойки (2 ^ B).

Поэтому в программе fixed-число хранятся как целое числао`self.value` (соответствует x), при этом есть переменная `denom` (denominator - соответствует y), таким образом экземпляр класса соответсвует числу `self.value / denom`

используется только при умножении или делении. Реализовано внутри

### Арифметические операции

**Сумма и разность**

Просто сумма или разность `value` операндов

**Умножение**

Значения перемножаются, а далее происходит округление, совмещенное с делением на `denom` (f1 * f2 = `value1 / denom` * `value2 / denom` =
`(value1 * value2 / denom) / denom`) - реализцется функцией `__div__`

**Деление**

Сперва проверка на возможные ошибки

Далее числа приводятся к виду, чтобы делимое было положительным, а далее округление совмещенное с делением на делитель (значение второго) - также релизуется функцией `__div__`.

### Округление

**Функция** `__div__`

 Принимает аргумент quot, - значение, на которое надо поделить нынешнее значение `value`

Для деления используется целочисленное деление, встроенное в python (к -inf) - окргление к -inf реализуется именно так.

Округление к нулю реализовано с помощью выделения положительной части и встроенного целочисленного деления.

Округление к inf реализовано домножением на -1, округлением к -inf и снова домножением на -1.

Округление к ближайшему четному реализовано следующим образом: сначала проверяем, является ли число «полуцелым» (такое, что равноудалено от двух ближайших чисел, представимых в нужном формате). Если полуцелое, то перебираем два соседних целых числа и выбираем с четной последней цифрой. Если не полуцелое, то посмотрев на последнюю цифру выбираем ближайшее число.

Получив результат операции - к нему применяется операция `__upd__`, которая проверяет на переполнение и при необходимости проеобразовывает `value`.

## floating.py

Cодержит функцию `floating`, вызов которых реализует запрос на работу с числами с плавающей точкой.

Эта функция содержит класс `Floating`, экземпляр этого класса соответствует одному числу.

Также содержит класс `Constants`, экземпляр которого (переменная `consts`) содержит все необходимые константы для дальнейшей работы (длины экспоненты и мантиссы, сдвиг, наибольшая и наименьшая экспонент (для того, чтобы в дальнейшем определять, к какой категории относится то или иное число), битовые представления для особенных значений: 0, -0, inf, -inf, nan, а также битовые представления для наибольших/наименьших чисел, чтобы использовать их при округлении)

Элементарные функции на проверку, является ли число особенным.

Так же в функции реализовано само получение результата функцией `get_res`.

Числа инициализируются своим представление в 16-ричной СС, а также необходимыми константами.

## Класс Floating - реализация чисел с плавающей точкой

### Хранение

floating-число представляется в виде man * 2 ^ exp (1 ≤ man < 2)

Число хранится как экземпляр класса `Floating`. У экземпляра имеются следующие поля:

- знак числа
- значение экспоненты (которая будет выводиться)
- мантисса хранится как целое число - такое, что при делении этого числа на 2 ^ `len_man` (длина мантиссы) - получится man (из представления)

Также есть поле `bin_repr`, для представления того, как хранится в памяти.

Вспомогательные поля - является ли число нормализованным, денормализованным, нелувым, ьесконечностью или nan-ом.

### Арифметические операции

Сперва идет проверка на nan: результат всех операций с ними - тоже nan.

Все арифметические операции также сперва делают проверку на особые случаи: операции с нулями и бесконечностями.

Далее внутри каждой операции реализовано получение (а как получено - описано будет ниже) следующих значений:

- `sgn` - знак результата
- `exp` - экспонента результата
- `bin_man` - битовое представление мантиссы - от этого значения нужно отрезать хвост и округлить - получится необходимая мантисся

Далее эти значения передаются функции transform. 

Используя значение экспоненты эта функция проверяет, не получилось ли очень большое или очень маленькое число. Проверяет, получилось нормализованное, или денормализованное число. И каждое из них округляется в соответсвии с типом этого числа и его знака.

Далее инициализируется число-результат, используя знак, округленнуюю мантиссу и экспоненту.

Может произойти такое, что при округлении число перейдет из одного типа в друго (например было нормализованным, а стало денормализованным), такие случаи учтены парочкой if-ов.

**Получение** `sgn`, `exp`, `bin_man`:

**Умножение**

`sgn`: xor знаков операндов. (0 - положительное, 1 - отрицательное)

Отдельно разбирается случай произведения денормализованных - это всегда очень маленькое число, и оно округляется либо в 0 либо в число с минимальным модулем.

`bin_man`: бинарное представление от произведения мантисс операндов

`exp`: сумма экспонент и переменной `to_add`, которая говорит о еще некоторых изменениях экпоненты: eсли при умножении мантисс увеличилось количество разрядов, или если было число денормализованное, то необходимо определить сдвиг в этом случае

**Сложение и вычитание**

(вычитание - сумма с противоположным)

`sgn`: вызов устраивается так, чтобы первое число было по модулю больше второго, таким образом знак результата - знак первого операнда.

`exp`: экспонента первого + переменная `to_add` - которая отслеживает, насколько изменилась мантисса после приведения к общему знаменателю и суммирования.

`bin_man`: приведение к общему знаменателю (домножение на необходимую степень двойки) и сумма получившихся значений (в соответсвии со знаком).

**Деление**

`sgn`:  xor знаков операндов. (0 - положительное, 1 - отрицательное)

Далее мы приводим операнды к такому виду, чтобы мантисса первого была не менее второй, но если больше, то менее чем в 2 раза - это мы делаем умножая на 2 мантисуу и одновременно уменьшая экспоненту на 1.

`bin_man`: так как нас интересует начало бинарной записи, то его длин нас не интересует, поэтому чтобы получить достаточную четность - мы получаем `bin_man` как целочисленное отношение мантисс, но первая домножена на большую степень двойки, чтобы получить достаточную точность.

`exp`: разность экспонент операндов

### Округление:

Для округления используются `sgn` и `bin_man`:

Сперва проверяется, нужно ли вообще округлять

Далее в зависимости от типа и округления программа понимает - нужно взять большее (`__next__`) или меньшее (`__prev__`):

- -inf: всегда `__prev__`
- inf: всегда `__next__`
- 0: для отрицательных `__prev__`, для положительных `__next__`
- nearest_even: Проверяет, полуцелое ли. Если да - ищет ближайшее четное и к нему. Иначе вычисляет ближайшее и округляет к нему.

 А далее каждая из функций `__next__` ,`__prev__` обрезает бинарную запись и увеличивает/уменьшает в зависимости от функции.